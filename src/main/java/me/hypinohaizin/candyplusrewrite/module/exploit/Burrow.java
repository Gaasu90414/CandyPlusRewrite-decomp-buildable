//Deobfuscated with https://github.com/SimplyProgrammer/Minecraft-Deobfuscator3000 using mappings "C:\Users\gaasu\Downloads\Minecraft-Deobfuscator3000-master\1.12 stable mappings"!

package me.hypinohaizin.candyplusrewrite.module.exploit;

import java.util.Iterator;
import me.hypinohaizin.candyplusrewrite.module.Module;
import me.hypinohaizin.candyplusrewrite.setting.Setting;
import me.hypinohaizin.candyplusrewrite.utils.BlockUtil;
import me.hypinohaizin.candyplusrewrite.utils.InventoryUtil;
import net.minecraft.entity.Entity;
import net.minecraft.entity.item.EntityItem;
import net.minecraft.init.Blocks;
import net.minecraft.network.play.client.CPacketEntityAction;
import net.minecraft.network.play.client.CPacketHeldItemChange;
import net.minecraft.network.play.client.CPacketEntityAction.Action;
import net.minecraft.network.play.client.CPacketPlayer.Position;
import net.minecraft.util.EnumHand;
import net.minecraft.util.math.AxisAlignedBB;
import net.minecraft.util.math.BlockPos;

public class Burrow extends Module {
   private final Setting<Float> offset = this.register(new Setting("Offset", 7.0F, 30.0F, -20.0F));
   private final Setting<Boolean> sneak = this.register(new Setting("Sneak", false));
   private final Setting<Boolean> echest = this.register(new Setting("EChest", false));
   private final Setting<Boolean> sushiBypass = this.register(new Setting("Bypass", false));
   private BlockPos originalPos;
   private int oldSlot = -1;

   public Burrow() {
      super("Burrow", Module.Categories.EXPLOIT, false, false);
   }

   public void onEnable() {
      super.onEnable();
      this.originalPos = new BlockPos(mc.player.posX, mc.player.posY, mc.player.posZ);
      if (!mc.world.getBlockState(new BlockPos(mc.player.posX, mc.player.posY, mc.player.posZ)).getBlock().equals(Blocks.OBSIDIAN) && !this.intersectsWithEntity(this.originalPos)) {
         this.oldSlot = mc.player.inventory.currentItem;
      } else {
         this.toggle();
      }
   }

   public void onTick() {
      if ((InventoryUtil.findHotbarBlock(Blocks.OBSIDIAN) != -1 || (Boolean)this.echest.getValue()) && (InventoryUtil.findHotbarBlock(Blocks.ENDER_CHEST) != -1 || !(Boolean)this.echest.getValue())) {
         switchToSlot(InventoryUtil.findHotbarBlock((Boolean)this.echest.getValue() ? Blocks.ENDER_CHEST : Blocks.OBSIDIAN));
         mc.player.connection.sendPacket(new Position(mc.player.posX, mc.player.posY + 0.41999998688698D, mc.player.posZ, true));
         mc.player.connection.sendPacket(new Position(mc.player.posX, mc.player.posY + 0.7531999805211997D, mc.player.posZ, true));
         mc.player.connection.sendPacket(new Position(mc.player.posX, mc.player.posY + 1.00133597911214D, mc.player.posZ, true));
         mc.player.connection.sendPacket(new Position(mc.player.posX, mc.player.posY + 1.16610926093821D, mc.player.posZ, true));
         boolean sneaking = mc.player.isSneaking();
         if ((Boolean)this.sneak.getValue() && sneaking) {
            mc.player.connection.sendPacket(new CPacketEntityAction(mc.player, Action.START_SNEAKING));
         }

         BlockUtil.placeBlock(this.originalPos, EnumHand.MAIN_HAND, false, true, sneaking);
         if ((Boolean)this.sushiBypass.getValue()) {
            mc.player.connection.sendPacket(new Position(mc.player.posX, mc.player.posY - 1.11D, mc.player.posZ, false));
         }

         mc.player.connection.sendPacket(new Position(mc.player.posX, mc.player.posY + (double)(Float)this.offset.getValue(), mc.player.posZ, false));
         switchToSlot(this.oldSlot);
         if ((Boolean)this.sneak.getValue() && sneaking) {
            mc.player.connection.sendPacket(new CPacketEntityAction(mc.player, Action.STOP_SNEAKING));
         }

         this.toggle();
      } else {
         this.sendMessage("Can't find material in hotbar!");
         this.toggle();
      }
   }

   private boolean intersectsWithEntity(BlockPos pos) {
      Iterator var2 = mc.world.loadedEntityList.iterator();

      Entity entity;
      do {
         if (!var2.hasNext()) {
            return false;
         }

         entity = (Entity)var2.next();
      } while(entity.equals(mc.player) || entity instanceof EntityItem || !(new AxisAlignedBB(pos)).intersects(entity.getEntityBoundingBox()));

      return true;
   }

   public static void switchToSlot(int slot) {
      mc.player.connection.sendPacket(new CPacketHeldItemChange(slot));
      mc.player.inventory.currentItem = slot;
      mc.playerController.updateController();
   }
}
