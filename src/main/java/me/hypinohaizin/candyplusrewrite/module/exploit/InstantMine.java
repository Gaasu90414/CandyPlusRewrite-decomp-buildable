//Deobfuscated with https://github.com/SimplyProgrammer/Minecraft-Deobfuscator3000 using mappings "C:\Users\gaasu\Downloads\Minecraft-Deobfuscator3000-master\1.12 stable mappings"!

package me.hypinohaizin.candyplusrewrite.module.exploit;

import java.awt.Color;
import me.hypinohaizin.candyplusrewrite.CandyPlusRewrite;
import me.hypinohaizin.candyplusrewrite.event.events.network.PacketEvent;
import me.hypinohaizin.candyplusrewrite.event.events.world.BlockEvent;
import me.hypinohaizin.candyplusrewrite.module.Module;
import me.hypinohaizin.candyplusrewrite.setting.Setting;
import me.hypinohaizin.candyplusrewrite.utils.InventoryUtil;
import me.hypinohaizin.candyplusrewrite.utils.RenderUtil3D;
import me.hypinohaizin.candyplusrewrite.utils.Timer;
import net.minecraft.block.Block;
import net.minecraft.block.state.IBlockState;
import net.minecraft.init.Items;
import net.minecraft.item.ItemStack;
import net.minecraft.network.Packet;
import net.minecraft.network.play.client.CPacketHeldItemChange;
import net.minecraft.network.play.client.CPacketPlayerDigging;
import net.minecraft.network.play.client.CPacketPlayerDigging.Action;
import net.minecraft.util.EnumFacing;
import net.minecraft.util.EnumHand;
import net.minecraft.util.math.BlockPos;
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;

public class InstantMine extends Module {
   public Setting<Boolean> autoBreak = this.register(new Setting("AutoBreak", true));
   public Setting<Integer> delay = this.register(new Setting("Delay", 20, 500, 0));
   public Setting<Boolean> picOnly = this.register(new Setting("Only Pickaxe", true));
   public Setting<Color> color = this.register(new Setting("Color", new Color(0, 0, 230, 90)));
   public Setting<Boolean> outline = this.register(new Setting("Outline", false));
   public Setting<Float> width = this.register(new Setting("Width", 2.0F, 5.0F, 0.2F, (v) -> {
      return (Boolean)this.outline.getValue();
   }));
   public Setting<Boolean> silentSwitch = this.register(new Setting("SilentSwitch", true));
   private static boolean packetCancel = false;
   private static Timer breaktimer = new Timer();
   private static Timer timer = new Timer();
   private static EnumFacing direction;
   public static BlockPos FourZeroFourBlock;
   private static BlockPos lastBlock;
   private int previousSlot = -1;

   public InstantMine() {
      super("InstantMine", Module.Categories.EXPLOIT, false, false);
   }

   public void onRender3D() {
      if (FourZeroFourBlock != null) {
         RenderUtil3D.drawBox(FourZeroFourBlock, 1.0D, (Color)this.color.getValue(), 63);
         if ((Boolean)this.outline.getValue()) {
            RenderUtil3D.drawBoundingBox(FourZeroFourBlock, 1.0D, (Float)this.width.getValue(), (Color)this.color.getValue());
         }
      }

   }

   public void onUpdate() {
      if (!CandyPlusRewrite.m_module.getModuleWithClass(SilentPickel.class).isEnable) {
         this.update();
      }

   }

   public void update() {
      if (!this.nullCheck()) {
         if (FourZeroFourBlock != null && (Boolean)this.autoBreak.getValue() && breaktimer.passedMs((long)(Integer)this.delay.getValue())) {
            if ((Boolean)this.picOnly.getValue()) {
               int bestPickSlot = this.getFastestPickaxeSlot();
               if (bestPickSlot == -1) {
                  return;
               }

               this.previousSlot = mc.player.inventory.currentItem;
               if ((Boolean)this.silentSwitch.getValue()) {
                  mc.player.connection.sendPacket(new CPacketHeldItemChange(bestPickSlot));
               } else {
                  InventoryUtil.switchToHotbarSlot(bestPickSlot, true);
               }

               mc.player.connection.sendPacket(new CPacketPlayerDigging(Action.STOP_DESTROY_BLOCK, FourZeroFourBlock, direction));
               if ((Boolean)this.silentSwitch.getValue() && this.previousSlot != -1) {
                  mc.player.connection.sendPacket(new CPacketHeldItemChange(this.previousSlot));
               } else {
                  InventoryUtil.switchToHotbarSlot(this.previousSlot, true);
               }
            } else {
               mc.player.connection.sendPacket(new CPacketPlayerDigging(Action.STOP_DESTROY_BLOCK, FourZeroFourBlock, direction));
            }

            breaktimer.reset();
         }

      }
   }

   private int getFastestPickaxeSlot() {
      int bestSlot = -1;
      float bestSpeed = 0.0F;

      for(int i = 0; i < 9; ++i) {
         ItemStack stack = mc.player.inventory.getStackInSlot(i);
         if (stack.getItem() == Items.DIAMOND_PICKAXE) {
            float speed = stack.getDestroySpeed(mc.world.getBlockState(FourZeroFourBlock));
            if (speed > bestSpeed) {
               bestSpeed = speed;
               bestSlot = i;
            }
         }
      }

      return bestSlot;
   }

   public void onPacketSend(PacketEvent.Send event) {
      if (!this.nullCheck()) {
         Packet<?> packet = event.getPacket();
         if (packet instanceof CPacketPlayerDigging && ((CPacketPlayerDigging)packet).getAction() == Action.START_DESTROY_BLOCK && packetCancel) {
            event.cancel();
         }

      }
   }

   @SubscribeEvent
   public void OnDamageBlock(BlockEvent event) {
      if (!this.nullCheck()) {
         if (this.isEnable) {
            startBreak(event.pos, event.facing);
            event.cancel();
         }
      }
   }

   public static void startBreak(BlockPos pos, EnumFacing facing) {
      if (!canBreak(pos)) {
         resetMining();
      } else {
         if (lastBlock == null || !pos.equals(lastBlock)) {
            resetMining();
            packetCancel = false;
            mc.player.swingArm(EnumHand.MAIN_HAND);
            mc.player.connection.sendPacket(new CPacketPlayerDigging(Action.START_DESTROY_BLOCK, pos, facing));
         }

         packetCancel = true;
         mc.player.connection.sendPacket(new CPacketPlayerDigging(Action.STOP_DESTROY_BLOCK, pos, facing));
         FourZeroFourBlock = pos;
         lastBlock = pos;
         direction = facing;
      }
   }

   private static boolean canBreak(BlockPos pos) {
      IBlockState blockState = mc.world.getBlockState(pos);
      Block block = blockState.getBlock();
      return block.getBlockHardness(blockState, mc.world, pos) != -1.0F;
   }

   public static void cancelMining() {
      if (FourZeroFourBlock != null && direction != null) {
         mc.player.connection.sendPacket(new CPacketPlayerDigging(Action.ABORT_DESTROY_BLOCK, FourZeroFourBlock, direction));
         resetMining();
      }

   }

   public static void resetMining() {
      FourZeroFourBlock = null;
      lastBlock = null;
      direction = null;
      packetCancel = false;
   }
}
