//Deobfuscated with https://github.com/SimplyProgrammer/Minecraft-Deobfuscator3000 using mappings "C:\Users\gaasu\Downloads\Minecraft-Deobfuscator3000-master\1.12 stable mappings"!

package me.hypinohaizin.candyplusrewrite.module.exploit;

import me.hypinohaizin.candyplusrewrite.module.Module;
import me.hypinohaizin.candyplusrewrite.setting.Setting;
import me.hypinohaizin.candyplusrewrite.utils.BlockUtil;
import me.hypinohaizin.candyplusrewrite.utils.InventoryUtil;
import me.hypinohaizin.candyplusrewrite.utils.PlayerUtil;
import net.minecraft.block.BlockTrapDoor;
import net.minecraft.entity.Entity;
import net.minecraft.entity.item.EntityEnderCrystal;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.init.Blocks;
import net.minecraft.network.play.client.CPacketHeldItemChange;
import net.minecraft.network.play.client.CPacketPlayer.Position;
import net.minecraft.util.EnumFacing;
import net.minecraft.util.EnumHand;
import net.minecraft.util.math.AxisAlignedBB;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.Vec3d;

public class TrapPhase extends Module {
   public Setting<Float> offset = this.register(new Setting("Offset", 0.6F, 1.0F, 0.0F));
   public Setting<Boolean> silentSwitch = this.register(new Setting("SilentSwitch", true));
   public Setting<Boolean> packetPlace = this.register(new Setting("PacketPlace", true));
   private EnumHand oldhand = null;
   private int oldslot = -1;

   public TrapPhase() {
      super("TrapPhase", Module.Categories.EXPLOIT, false, false);
   }

   public void onTick() {
      if (!this.nullCheck()) {
         int slot = InventoryUtil.findHotbarBlockWithClass(BlockTrapDoor.class);
         if (slot == -1) {
            this.sendMessage("Cannot find TrapDoor! disabling");
            this.disable();
         } else {
            BlockPos playerPos = PlayerUtil.getPlayerPos();
            BlockPos trappos = null;
            BlockPos[] array = new BlockPos[]{new BlockPos(1, 0, 0), new BlockPos(-1, 0, 0), new BlockPos(0, 0, 1), new BlockPos(0, 0, -1)};
            BlockPos[] var6 = array;
            int var7 = array.length;

            for(int var8 = 0; var8 < var7; ++var8) {
               BlockPos offset = var6[var8];
               BlockPos pos = playerPos.add(offset);
               if (this.entityCheck(pos) && (!BlockUtil.getBlock(pos).equals(Blocks.AIR) || !BlockUtil.canRightClickForPlace(pos))) {
                  trappos = pos;
               }
            }

            if (trappos == null) {
               this.sendMessage("Cannot find space! disabling");
               this.disable();
            } else {
               this.setItem(slot);
               double x = mc.player.posX;
               double y = mc.player.posY;
               double z = mc.player.posZ;
               mc.player.connection.sendPacket(new Position(x, y + (double)(Float)this.offset.getValue(), z, mc.player.onGround));
               EnumFacing facing = null;
               EnumFacing[] var13 = EnumFacing.values();
               int var14 = var13.length;

               for(int var15 = 0; var15 < var14; ++var15) {
                  EnumFacing f = var13[var15];
                  if (trappos.add(f.getDirectionVec()).equals(playerPos)) {
                     facing = f;
                  }
               }

               BlockUtil.rightClickBlock(trappos, facing, new Vec3d(0.5D, 0.8D, 0.5D), (Boolean)this.packetPlace.getValue());
               mc.player.connection.sendPacket(new Position(x, y, z, mc.player.onGround));
               this.restoreItem();
               this.disable();
            }
         }
      }
   }

   public boolean entityCheck(BlockPos pos) {
      return mc.world.getEntitiesWithinAABB(Entity.class, new AxisAlignedBB(pos), (e) -> {
         return e instanceof EntityEnderCrystal || e instanceof EntityPlayer;
      }).isEmpty();
   }

   public void setItem(int slot) {
      if ((Boolean)this.silentSwitch.getValue()) {
         this.oldhand = null;
         if (mc.player.isHandActive()) {
            this.oldhand = mc.player.getActiveHand();
         }

         this.oldslot = mc.player.inventory.currentItem;
         mc.player.connection.sendPacket(new CPacketHeldItemChange(slot));
      } else {
         mc.player.inventory.currentItem = slot;
         mc.playerController.updateController();
      }

   }

   public void restoreItem() {
      if (this.oldslot != -1 && (Boolean)this.silentSwitch.getValue()) {
         if (this.oldhand != null) {
            mc.player.setActiveHand(this.oldhand);
         }

         mc.player.connection.sendPacket(new CPacketHeldItemChange(this.oldslot));
         this.oldslot = -1;
         this.oldhand = null;
      }

   }
}
